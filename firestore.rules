
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // By default, deny all reads and writes
    match /{document=**} {
      allow read, write: if false;
    }

    // ========= HELPER FUNCTIONS =========
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAccountAdmin(accountId) {
      // Use the user's profile document to check for admin role.
      // This requires the user running the check to be able to read their own user profile.
      let userProfile = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isSignedIn() && userProfile.data.accounts[accountId] == 'admin';
    }

    function isAccountMember(accountId) {
      // Use the user's profile document to check for any role in the account.
      let userProfile = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isSignedIn() && userProfile.data.accounts[accountId] != null;
    }

    // ========= ROOT COLLECTIONS =========
    
    // The `users` collection stores a profile for every authenticated user.
    match /users/{userId} {
      // A user can create their own profile.
      allow create: if isUser(userId);
      
      // A user can read their own profile.
      allow read: if isUser(userId);

      // A user can update their own profile.
      // An account admin can also update a user's profile, but ONLY to remove that user
      // from the account they administrate. This is for revoking manager access.
      allow update: if isUser(userId) || (
        // The only change is to the 'accounts' map
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['accounts']) &&
        // The size of the map is decreasing by one
        request.resource.data.accounts.size() == resource.data.accounts.size() - 1 &&
        // There exists an accountId that was in the old map but not the new one,
        // AND the requester is an admin of that specific account.
        resource.data.accounts.keys().exists(
          accountId => !(accountId in request.resource.data.accounts) && isAccountAdmin(accountId)
        )
      );
      
      // No one can list all users or delete profiles from the client.
      allow list, delete: if false;
    }
    
    // The `invitations` collection stores invites for users to manage auctions.
    match /invitations/{inviteId} {
      // An admin of the target account can create or delete invites.
      allow create: if isAccountAdmin(request.resource.data.accountId);
      allow delete: if isAccountAdmin(resource.data.accountId);
      
      // An admin can read their own invites. The invited user can read their own invite once logged in.
      allow get: if isAccountAdmin(resource.data.accountId) || 
                   (isSignedIn() && request.auth.token.email.lower() == resource.data.email.lower());
      
      // An admin can list the invites for their account via a query.
      allow list: if isSignedIn() && request.query.accountId != null && isAccountAdmin(request.query.accountId);
                   
      // The invited user can update their own invite to accept it.
      allow update: if isSignedIn() && request.auth.token.email.lower() == resource.data.email.lower();
    }
    
    // `accounts` holds all tenant data. Access is controlled by the user's profile.
    match /accounts/{accountId} {
      // A user can create their own account document. This happens in the same
      // batch as user profile creation, so we check the incoming request data.
      allow create: if isUser(request.resource.data.adminUserId) && request.resource.data.id == accountId;

      // Only a member of the account can read the account document.
      allow read: if isAccountMember(accountId);
      
      // Only the admin of the account can update or delete it.
      allow update, delete: if isAccountAdmin(accountId);

      // Disallow listing all accounts for security.
      allow list: if false;

      // --- Subcollections of an Account ---
      
      match /patrons/{patronId} {
          allow read, write: if isAccountMember(accountId);
      }

      match /donors/{donorId} {
          allow read, write: if isAccountMember(accountId);
      }
      
      // Auctions have more granular rules for managers.
      match /auctions/{auctionId} {
        
        function isAuctionManager() {
          // Check the currently stored data, not the incoming request data.
          return isSignedIn() && resource.data.managers[request.auth.uid] == true;
        }

        // Any account member can read or create an auction.
        allow read, create: if isAccountMember(accountId);
        
        // Only admins or auction managers can delete an auction.
        allow delete: if isAccountAdmin(accountId) || isAuctionManager();

        // Update logic is the most complex.
        allow update: if 
          // An account admin can always update.
          isAccountAdmin(accountId) ||
          // An existing auction manager can update.
          isAuctionManager() ||
          // A new user accepting a valid invite can add themselves to the managers list.
          (
            isAccountMember(accountId) &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['managers']) &&
            request.resource.data.managers.size() == resource.data.managers.size() + 1 &&
            request.resource.data.managers[request.auth.uid] == true
          );

        // Rules for auction subcollections inherit from the auction's permissions.
        match /{subcollection}/{docId} {
            // Only account admins or auction managers can read/write items, lots, etc.
            allow read, write: if isAccountAdmin(accountId) || isAuctionManager();
        }
      }
    }
  }
}
